<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Î¶¨Ïñº Ïö∞Ï£º Ï§ëÎ†• Í≥®ÌîÑ v0.8.0 (Turn-Based League)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #020617; font-family: 'Rajdhani', sans-serif; touch-action: none; user-select: none; }
        .font-sci { font-family: 'Orbitron', sans-serif; }
        .hidden { display: none !important; }
        
        .fade-in { animation: fadeIn 0.4s ease-out forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        
        .btn-menu {
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.9) 0%, rgba(15, 23, 42, 0.95) 100%);
            border: 1px solid rgba(148, 163, 184, 0.2);
            transition: all 0.2s; cursor: pointer; touch-action: manipulation;
        }
        .btn-menu:active { transform: scale(0.97); background: rgba(59, 130, 246, 0.2); }

        /* UI */
        #gauge-container-group { 
            position: absolute; bottom: 130px; left: 50%; transform: translateX(-50%); 
            display: none; gap: 10px; z-index: 50; align-items: flex-end; 
            width: 90%; max-width: 500px; justify-content: center;
            background: rgba(0,0,0,0.8); padding: 12px; border-radius: 20px; border: 1px solid #475569;
            transition: all 0.3s ease;
        }
        #gauge-bar, #gauge-height-wrapper { background: #0f172a; border: 2px solid #64748b; border-radius: 8px; position: relative; overflow: hidden; }
        #gauge-height-wrapper { width: 30px; height: 120px; transition: width 0.3s, opacity 0.3s; }
        #gauge-bar { width: 100%; height: 30px; border-radius: 15px; }
        #gauge-power-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #4ade80, #eab308, #ef4444); }
        #gauge-height-fill { width: 100%; height: 0%; bottom: 0; position: absolute; background: linear-gradient(0deg, #3b82f6, #a855f7); }
        .cursor-indicator { position: absolute; background: #fff; box-shadow: 0 0 8px #fff; z-index: 20; }
        #gauge-cursor { width: 4px; height: 100%; top: 0; left: 0; }
        #gauge-height-cursor { width: 100%; height: 3px; bottom: 0; left: 0; }
        .putting-active { border-color: #4ade80 !important; box-shadow: 0 0 20px rgba(74, 222, 128, 0.3) !important; }
        .putting-active #gauge-height-wrapper { width: 0 !important; border: none; opacity: 0; margin: 0; }
        
        #minimap-container { position: absolute; top: 90px; right: 20px; width: 130px; height: 130px; background: #000; border: 2px solid #475569; border-radius: 50%; overflow: hidden; z-index: 50; display: none; }
        #minimap-canvas { width: 100%; height: 100%; display: block; }
        
        .mobile-controls { display: none; position: absolute; bottom: 30px; z-index: 60; width: 100%; justify-content: space-between; padding: 0 30px; pointer-events: none; }
        .control-btn { pointer-events: auto; width: 75px; height: 75px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px; color: white; backdrop-filter: blur(4px); transition: 0.1s; }
        .control-btn:active { background: rgba(255,255,255,0.2); transform: scale(0.9); }
        .control-btn.shot-btn { width: 95px; height: 95px; background: linear-gradient(135deg, rgba(234, 179, 8, 0.2), rgba(234, 179, 8, 0.4)); border-color: rgba(253, 224, 71, 0.5); color: #fef08a; font-weight: 900; font-size: 18px; font-family: 'Orbitron'; }

        #turn-notification { position: absolute; top: 20%; left: 50%; transform: translateX(-50%); z-index: 100; font-family: 'Orbitron'; font-weight: 900; font-size: 2rem; color: white; text-shadow: 0 0 20px rgba(0,0,0,0.8); pointer-events: none; opacity: 0; transition: opacity 0.3s; width: 100%; text-align: center; }
        .show-turn { opacity: 1 !important; animation: bounceIn 0.5s; }
        @keyframes bounceIn { 0% { transform: translateX(-50%) scale(0.5); } 80% { transform: translateX(-50%) scale(1.1); } 100% { transform: translateX(-50%) scale(1); } }

        /* P2P Modal */
        #p2p-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 150; display: none; justify-content: center; align-items: center; flex-direction: column; }
        .p2p-box { background: #1e293b; padding: 30px; border-radius: 20px; border: 1px solid #475569; text-align: center; width: 90%; max-width: 400px; }
        
        #multi-status { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); font-size: 12px; color: #4ade80; z-index: 60; display: none; background: rgba(0,0,0,0.7); padding: 5px 15px; border-radius: 20px; border: 1px solid #4ade80; }
        
        #loader { position: fixed; inset: 0; background: #020617; z-index: 200; display: flex; justify-content: center; align-items: center; color: white; flex-direction: column; }
        .spinner { width: 40px; height: 40px; border: 4px solid #1e293b; border-top: 4px solid #3b82f6; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 15px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* Juice */
        .shake-screen { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }
    </style>
</head>
<body class="text-white">

    <div id="loader">
        <div class="spinner"></div>
        <p class="font-sci tracking-widest text-blue-400 text-sm">LOADING LEAGUE v0.8.0</p>
    </div>

    <div id="multi-status">üü¢ ONLINE</div>
    <div id="turn-notification">YOUR TURN</div>

    <!-- 1. Î°úÎπÑ -->
    <div id="lobby-screen" class="absolute inset-0 z-50 flex flex-col items-center justify-center bg-slate-950/95 backdrop-blur-md fade-in hidden">
        <div class="text-center mb-10 relative">
            <h1 class="relative text-5xl md:text-7xl font-black text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500 font-sci mb-2 tracking-tighter">
                GRAVITY<span class="text-white">GOLF</span>
            </h1>
            <p class="text-slate-400 text-xs md:text-sm font-sci tracking-[0.6em] opacity-80">UNIVERSE LEAGUE v0.8.0</p>
        </div>
        
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 w-full max-w-4xl px-6 pb-6 overflow-y-auto" style="max-height: 60vh;">
            <div class="btn-menu rounded-2xl p-6 flex items-center gap-4 group border-l-4 border-green-400" onclick="GameApp.selectMode('TOUR')">
                <div class="text-3xl">ü™ê</div><div><h3 class="text-lg font-bold font-sci">SOLO TOUR</h3><p class="text-xs text-slate-400">Practice & Records</p></div>
            </div>
            
            <div class="btn-menu rounded-2xl p-6 flex items-center gap-4 group border-l-4 border-yellow-400" onclick="GameApp.selectMode('SPEED')">
                <div class="text-3xl">‚ö°</div><div><h3 class="text-lg font-bold font-sci">SPEED RUSH</h3><p class="text-xs text-slate-400">Time Attack Mode</p></div>
            </div>
            
            <div class="btn-menu rounded-2xl p-6 flex items-center gap-4 group border-l-4 border-purple-500" onclick="GameApp.showMultiOptions()">
                <div class="text-3xl">üèÜ</div><div><h3 class="text-lg font-bold font-sci text-purple-400">MULTIPLAYER</h3><p class="text-xs text-slate-400">Turn-Based PvP</p></div>
            </div>
            
            <div class="btn-menu rounded-2xl p-6 flex items-center gap-4 group border-l-4 border-red-500" onclick="GameApp.selectMode('ONESHOT')">
                <div class="text-3xl">üéØ</div><div><h3 class="text-lg font-bold font-sci">ONE SHOT</h3><p class="text-xs text-slate-400">Hardcore Survival</p></div>
            </div>
        </div>
    </div>

    <!-- P2P Î™®Îã¨ -->
    <div id="p2p-modal" class="hidden">
        <div id="multi-select" class="p2p-box">
            <h2 class="text-2xl font-bold font-sci mb-6 text-purple-400">LEAGUE MATCH</h2>
            <button onclick="GameApp.showP2POptions()" class="w-full bg-purple-600 hover:bg-purple-500 text-white font-bold py-4 rounded-xl mb-4">
                ü§ù VS FRIEND <span class="text-xs font-normal block text-purple-200">Create Room Code</span>
            </button>
            <button onclick="GameApp.closeP2P()" class="text-slate-400 text-sm mt-2 hover:text-white">CANCEL</button>
        </div>

        <div id="p2p-options" class="p2p-box hidden">
            <h2 class="text-2xl font-bold font-sci mb-6 text-purple-400">CONNECTION</h2>
            <div class="flex gap-4">
                <button onclick="GameApp.openP2P('HOST')" class="flex-1 bg-slate-700 hover:bg-slate-600 py-6 rounded-xl font-bold">üè† HOST</button>
                <button onclick="GameApp.openP2P('JOIN')" class="flex-1 bg-slate-700 hover:bg-slate-600 py-6 rounded-xl font-bold">üöÄ JOIN</button>
            </div>
            <button onclick="GameApp.backToMultiSelect()" class="text-slate-400 text-sm mt-4 hover:text-white">BACK</button>
        </div>

        <div id="p2p-host" class="p2p-box hidden">
            <h2 class="text-xl font-bold font-sci mb-2">ROOM CODE</h2>
            <div id="room-code-display" onclick="GameApp.copyCode()" class="text-3xl font-black text-white bg-black/50 p-4 rounded-lg cursor-pointer hover:text-yellow-400 transition">-----</div>
            <p class="text-xs text-slate-500 mt-2 mb-4">Share this code with your friend</p>
            <div class="animate-pulse text-green-400 text-sm">Waiting for opponent...</div>
            <button onclick="GameApp.closeP2P()" class="mt-6 px-6 py-2 bg-slate-700 rounded-lg text-sm">CANCEL</button>
        </div>

        <div id="p2p-join" class="p2p-box hidden">
            <h2 class="text-xl font-bold font-sci mb-4">ENTER CODE</h2>
            <input type="text" id="room-code-input" placeholder="CODE" class="w-full bg-black/50 border border-slate-600 p-3 text-center text-xl font-sci text-white rounded-lg mb-4 focus:border-purple-500 outline-none uppercase tracking-widest">
            <button onclick="GameApp.connectToPeer()" class="w-full bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 rounded-lg mb-2">CONNECT</button>
            <button onclick="GameApp.closeP2P()" class="w-full bg-slate-700 hover:bg-slate-600 text-white font-bold py-3 rounded-lg">CANCEL</button>
        </div>
    </div>

    <!-- 2. Ïù∏Í≤åÏûÑ HUD -->
    <div id="in-game-ui" class="absolute inset-0 pointer-events-none hidden z-10">
        <!-- Scoreboard (Multi Only) -->
        <div id="scoreboard" class="absolute top-20 right-6 bg-black/50 p-2 rounded-lg text-xs text-right hidden">
            <div class="text-cyan-400 font-bold">ME: <span id="score-me">0</span></div>
            <div class="text-red-400 font-bold">OP: <span id="score-op">0</span></div>
        </div>

        <div class="absolute top-6 left-6 pointer-events-auto flex items-center gap-4 bg-black/60 p-3 rounded-2xl border border-white/10 backdrop-blur-md z-50">
            <div class="w-10 h-10 rounded-full bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center text-xl shadow-inner">ü™ê</div>
            <div>
                <h2 id="hud-planet-name" class="text-sm font-bold font-sci text-white leading-none mb-1">PLANET</h2>
                <p id="hud-planet-info" class="text-[10px] text-slate-300 font-mono tracking-wide">G: 1.00</p>
            </div>
        </div>

        <button onclick="ThreeScene.resetBall()" class="absolute top-6 left-1/2 transform -translate-x-1/2 pointer-events-auto bg-white/10 hover:bg-white/20 p-2 px-5 rounded-full text-[10px] font-bold border border-white/20 backdrop-blur-md transition z-50">
            ‚Ü∫ RESPAWN
        </button>

        <div class="absolute top-6 right-6 text-right bg-black/60 p-3 rounded-2xl border border-white/10 backdrop-blur-md z-50">
            <div class="text-3xl font-black font-sci text-white leading-none"><span id="hud-shots">0</span></div>
            <div id="hud-label" class="text-[10px] text-slate-400 font-bold tracking-widest">STROKES</div>
        </div>

        <div id="gauge-container-group" class="pointer-events-auto">
            <div id="gauge-height-wrapper">
                <div class="absolute top-2 w-full text-center text-[8px] font-bold text-white/50 z-20">ANG</div>
                <div id="gauge-height-fill"></div>
                <div id="gauge-height-cursor"></div>
            </div>
            <div style="position: relative; flex-grow: 1;">
                <div id="gauge-status" class="absolute top-[-35px] left-0 font-bold text-yellow-400 text-xs font-sci tracking-wider bg-black/80 px-3 py-1 rounded-full border border-yellow-500/30">READY</div>
                <div id="gauge-bar">
                    <div id="gauge-center-line"></div>
                    <div id="gauge-power-fill"></div>
                    <div id="gauge-cursor" class="cursor-indicator" style="left:0%;"></div>
                </div>
            </div>
        </div>

        <div id="minimap-container"><canvas id="minimap-canvas"></canvas></div>

        <div class="mobile-controls flex" id="mobile-controls">
            <div class="flex gap-4 items-end pb-4">
                <button class="control-btn" id="btn-left">‚óÄ</button>
                <button class="control-btn" id="btn-right">‚ñ∂</button>
            </div>
            <div class="flex items-end pb-4">
                <button class="control-btn shot-btn" id="btn-shot">HIT</button>
            </div>
        </div>
    </div>

    <!-- 3. Í≤∞Í≥º ÌôîÎ©¥ -->
    <div id="result-screen" class="hidden absolute inset-0 z-50 flex flex-col items-center justify-center bg-slate-900/95 backdrop-blur-xl fade-in">
        <h1 id="res-title" class="text-6xl font-black text-yellow-400 font-sci mb-6 tracking-tighter drop-shadow-2xl">FINISH</h1>
        <div class="bg-slate-800/80 p-8 rounded-3xl border border-slate-600 text-center w-[90%] max-w-[400px] shadow-2xl">
            <div class="text-5xl font-black mb-2 font-mono text-white" id="res-score">0</div>
            <div class="text-xs text-slate-400 mb-8 uppercase tracking-[0.2em]">TOTAL STROKES</div>
            
            <button onclick="GameApp.nextLevel()" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-4 rounded-xl mb-3 shadow-lg transition">NEXT HOLE üöÄ</button>
            <button onclick="GameApp.returnToLobby()" class="w-full bg-slate-700 hover:bg-slate-600 text-slate-300 font-bold py-3 rounded-xl transition">LOBBY</button>
        </div>
    </div>

    <div id="canvas-container" class="absolute inset-0 z-0"></div>

    <script>
        // --- 0. Audio & Boot ---
        const SoundMgr = (() => {
            const ctx = new (window.AudioContext||window.webkitAudioContext)();
            let enabled = true;
            function play(f,t,d,v){if(!enabled||ctx.state==='suspended')ctx.resume(); const o=ctx.createOscillator(),g=ctx.createGain(); o.type=t;o.frequency.setValueAtTime(f,ctx.currentTime);g.gain.setValueAtTime(v,ctx.currentTime);g.gain.exponentialRampToValueAtTime(0.01,ctx.currentTime+d);o.connect(g);g.connect(ctx.destination);o.start();o.stop(ctx.currentTime+d);}
            return {
                charge: v=>play(200+v*5,'triangle',0.1,0.1), 
                shot: ()=>{play(150,'sawtooth',0.2,0.3);play(80,'square',0.4,0.2);},
                bounce: v=>play(100+v*10,'sine',0.1,Math.min(v/50,0.5)), 
                holeIn: ()=>{[0,150,300].forEach((t,i)=>setTimeout(()=>play(400+i*100,'square',0.3,0.2),t));},
                toggle: ()=>{enabled=!enabled;}
            };
        })();

        setTimeout(()=>{
            const l=document.getElementById('loader');
            if(l&&!l.classList.contains('hidden')){l.classList.add('hidden');document.getElementById('lobby-screen').classList.remove('hidden');}
        }, 3000);

        // --- 1. Planet DB ---
        const PlanetDB = (() => {
            const colors = { EARTH: 0x4ade80, MARS: 0xc2410c, MOON: 0x94a3b8, ICE: 0xbfdbfe, LAVA: 0x7f1d1d };
            const planets = [];
            for(let i=0; i<300; i++) {
                const mapSize = 4000;
                const pathPoints = [new THREE.Vector3(0,0,1800)];
                const segments = 4 + (i%3);
                for(let j=1; j<segments; j++) pathPoints.push(new THREE.Vector3((Math.random()-0.5)*2000, 0, 1800-(j*(3600/segments))));
                pathPoints.push(new THREE.Vector3(0,0,-1800));
                
                let type="EARTH", col=colors.EARTH, grav=1.0;
                if(i%5===1) { type="MARS"; col=colors.MARS; grav=0.38; }
                else if(i%5===2) { type="MOON"; col=colors.MOON; grav=0.16; }
                else if(i%5===3) { type="ICE"; col=colors.ICE; grav=1.2; }
                else if(i%5===4) { type="LAVA"; col=colors.LAVA; grav=2.0; }

                planets.push({
                    id: i, name: `Sector-${i+1} [${type}]`, gravity: grav, par: 3 + Math.floor(segments/2), color: col, type: type,
                    pathPoints, startPos: pathPoints[0], holePos: pathPoints[pathPoints.length-1], width: 140 + Math.random()*50
                });
            }
            return {
                get: (id) => planets[id % planets.length],
                getRandom: () => planets[Math.floor(Math.random()*planets.length)]
            };
        })();

        // --- 2. Game Logic (Turn-Based P2P) ---
        window.GameApp = {
            state: 'LOBBY', mode: 'TOUR', currentStage: null, 
            peer: null, conn: null, myId: null, isHost: false, myTurn: true, 
            scoreMe: 0, scoreOp: 0,
            
            init() {
                try { ThreeScene.init(); } catch(e){}
                this.updateUI(); this.setupTouchControls();
                document.getElementById('loader').classList.add('hidden');
            },

            setupTouchControls() {
                const press=(k,p)=>ThreeScene.setKey(k,p);
                const prev=e=>{if(e.cancelable)e.preventDefault();};
                ['left','right'].forEach(d=>{
                    const b=document.getElementById(`btn-${d}`);
                    b.addEventListener('touchstart',e=>{prev(e);press(d==='left'?'a':'d',true);},{passive:false});
                    b.addEventListener('touchend',e=>{prev(e);press(d==='left'?'a':'d',false);});
                    b.addEventListener('mousedown',()=>press(d==='left'?'a':'d',true));
                    b.addEventListener('mouseup',()=>press(d==='left'?'a':'d',false));
                });
                const s=document.getElementById('btn-shot');
                s.addEventListener('touchstart',e=>{prev(e);ThreeScene.triggerSpace();s.style.transform='scale(0.9)';},{passive:false});
                s.addEventListener('touchend',e=>{prev(e);s.style.transform='scale(1)';});
                s.addEventListener('mousedown',()=>{ThreeScene.triggerSpace();s.style.transform='scale(0.9)';});
                s.addEventListener('mouseup',()=>{s.style.transform='scale(1)';});
            },

            updateUI() {
                ['lobby-screen','in-game-ui','result-screen','p2p-modal'].forEach(id=>{
                    const el=document.getElementById(id); if(el){el.classList.add('hidden');el.style.display='none';}
                });
                if(this.state==='LOBBY'){
                    document.getElementById('lobby-screen').classList.remove('hidden'); document.getElementById('lobby-screen').style.display='flex';
                } else if(this.state==='IN_GAME'){
                    document.getElementById('in-game-ui').classList.remove('hidden'); document.getElementById('in-game-ui').style.display='block';
                    document.querySelector('.mobile-controls').style.display='flex';
                    if(this.mode==='MULTI') document.getElementById('scoreboard').classList.remove('hidden');
                } else if(this.state==='RESULT'){
                    document.getElementById('result-screen').classList.remove('hidden'); document.getElementById('result-screen').style.display='flex';
                }
            },

            selectMode(m) { this.mode=m; this.myTurn=true; this.startGame(PlanetDB.getRandom()); },
            
            // --- Turn Based Multiplayer ---
            showMultiOptions() {
                const m = document.getElementById('p2p-modal'); m.classList.remove('hidden'); m.style.display='flex';
                document.getElementById('multi-select').classList.remove('hidden');
                document.getElementById('p2p-options').classList.add('hidden');
                document.getElementById('p2p-host').classList.add('hidden');
                document.getElementById('p2p-join').classList.add('hidden');
            },
            showP2POptions() { document.getElementById('multi-select').classList.add('hidden'); document.getElementById('p2p-options').classList.remove('hidden'); },
            backToMultiSelect() { document.getElementById('multi-select').classList.remove('hidden'); document.getElementById('p2p-options').classList.add('hidden'); },
            closeP2P() { document.getElementById('p2p-modal').style.display='none'; },

            openP2P(type) {
                if (typeof Peer === 'undefined') return alert("P2P Library Missing");
                document.getElementById('p2p-options').classList.add('hidden');
                if(!this.peer) {
                    this.peer = new Peer(null, { debug: 1 }); 
                    this.peer.on('open', (id) => { this.myId = id; if(type === 'HOST') this.setupHost(); });
                    this.peer.on('connection', (c) => { this.conn = c; this.setupConnection(); });
                } else { if(type === 'HOST') this.setupHost(); }
                if(type === 'JOIN') document.getElementById('p2p-join').classList.remove('hidden');
            },

            setupHost() {
                this.isHost = true;
                document.getElementById('p2p-host').classList.remove('hidden');
                document.getElementById('room-code-display').innerText = this.myId; 
                document.getElementById('room-code-display').style.fontSize = "14px";
            },

            connectToPeer() {
                const code = document.getElementById('room-code-input').value.trim();
                if(code.length < 5) return alert("Invalid Code");
                this.isHost = false;
                this.conn = this.peer.connect(code); 
                this.setupConnection();
            },

            setupConnection() {
                this.conn.on('open', () => {
                    this.closeP2P();
                    this.mode = 'MULTI';
                    document.getElementById('multi-status').style.display = 'block';
                    document.getElementById('multi-status').innerText = "üü¢ CONNECTED (P2P)";
                    
                    if(this.isHost) {
                        const pid = Math.floor(Math.random()*300);
                        this.myTurn = true; // Host First
                        this.conn.send({ type: 'START', planetId: pid, turn: !this.myTurn });
                        this.startGame(PlanetDB.get(pid));
                    }
                });
                this.conn.on('data', (data) => {
                    if(data.type === 'START') {
                        this.myTurn = data.turn; // Guest receives their turn state
                        this.startGame(PlanetDB.get(data.planetId));
                    }
                    if(data.type === 'POS_UPDATE') {
                        // Received Ghost Position
                        ThreeScene.updateGhostBall(data.pos);
                    }
                    if(data.type === 'TURN_END') {
                        this.myTurn = true;
                        this.showTurnNotification("YOUR TURN");
                        document.getElementById('score-op').innerText = data.score;
                    }
                    if(data.type === 'HOLE_IN') {
                        this.scoreOp = data.score;
                        document.getElementById('score-op').innerText = data.score;
                        if(this.state === 'RESULT') this.finishStage(this.scoreMe, "MATCH OVER"); 
                    }
                });
            },
            
            sendPosUpdate(pos) { if(this.conn && this.conn.open) this.conn.send({ type: 'POS_UPDATE', pos: pos }); },
            sendTurnEnd(score) { 
                if(this.conn && this.conn.open) {
                    this.conn.send({ type: 'TURN_END', score: score });
                }
                this.myTurn = false;
                this.showTurnNotification("OPPONENT TURN");
            },
            sendHoleIn(score) { if(this.conn && this.conn.open) this.conn.send({ type: 'HOLE_IN', score: score }); },
            
            showTurnNotification(text) {
                const el = document.getElementById('turn-notification');
                el.innerText = text;
                el.classList.add('show-turn');
                setTimeout(()=>el.classList.remove('show-turn'), 2000);
            },
            
            copyCode() { navigator.clipboard.writeText(this.myId); document.getElementById('copy-msg').innerText = "COPIED!"; },

            startGame(d) {
                this.state='IN_GAME'; this.currentStage=d;
                this.updateUI(); 
                this.scoreMe = 0; this.scoreOp = 0;
                
                if(this.mode === 'MULTI') {
                    if(this.myTurn) this.showTurnNotification("YOUR TURN");
                    else this.showTurnNotification("OPPONENT TURN");
                    document.getElementById('scoreboard').style.display = 'block';
                } else {
                    document.getElementById('scoreboard').style.display = 'none';
                    this.myTurn = true; // Always true in solo
                }
                
                ThreeScene.initStage(this.currentStage);
            },

            finishStage(s, title="COURSE CLEAR") {
                this.state='RESULT'; this.updateUI();
                this.scoreMe = s;
                document.getElementById('res-title').innerText = title;
                document.getElementById('res-score').innerText = s;
                SoundMgr.holeIn();
                if(this.mode === 'MULTI') this.sendHoleIn(s);
            },

            nextLevel() { 
                if(this.mode==='MULTI') {
                    // Sync Next level? For now, Host decides or simple restart
                    if(this.isHost) {
                        const pid = Math.floor(Math.random()*300);
                        this.conn.send({ type: 'START', planetId: pid, turn: false });
                        this.startGame(PlanetDB.get(pid));
                    }
                } else {
                    this.startGame(PlanetDB.getRandom()); 
                }
            },
            returnToLobby() { this.state='LOBBY'; this.updateUI(); },
        };

        // --- 3. Three.js Scene ---
        const ThreeScene = (() => {
            let scene,camera,renderer,ball,terrainMesh,gridHelper,trailMesh,obstacles=[];
            let gaugeState=0,gaugeVals={p:0,h:0,c:0},gaugeAnim={pos:0,dir:1};
            let physics={vel:new THREE.Vector3(),moving:false};
            let stageData,aimAngle=0,orbitAngle=0,shots=0,isPutting=false;
            let miniCtx,minimapBg,keys={a:false,d:false};
            let ghostBall, pathLut=[], trailPts=[];
            let shakeIntensity=0;

            function init() {
                const c=document.getElementById('canvas-container'); if(!c)return;
                scene=new THREE.Scene(); 
                camera=new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,8000);
                renderer=new THREE.WebGLRenderer({antialias:true}); renderer.setSize(window.innerWidth,window.innerHeight); renderer.shadowMap.enabled=true; c.appendChild(renderer.domElement);
                scene.add(new THREE.AmbientLight(0xffffff,0.6));
                const sun=new THREE.DirectionalLight(0xffffff,1.2); sun.position.set(500,1000,500); sun.castShadow=true; sun.shadow.mapSize.set(2048,2048); 
                sun.shadow.camera.far=5000; sun.shadow.camera.left=-2000; sun.shadow.camera.right=2000; sun.shadow.camera.top=2000; sun.shadow.camera.bottom=-2000;
                scene.add(sun);
                const sg=new THREE.BufferGeometry(); const sp=[];
                for(let i=0;i<3000;i++) sp.push((Math.random()-0.5)*8000,(Math.random()-0.5)*4000+2000,(Math.random()-0.5)*8000);
                sg.setAttribute('position',new THREE.Float32BufferAttribute(sp,3));
                scene.add(new THREE.Points(sg,new THREE.PointsMaterial({color:0xffffff,size:2})));
                const mc=document.getElementById('minimap-canvas'); if(mc){miniCtx=mc.getContext('2d');mc.width=300;mc.height=300;}
                animate();
                window.addEventListener('resize',()=>{camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight);});
                window.addEventListener('keydown',e=>{if(e.code==='Space')triggerSpace();if(e.code==='KeyA')keys.a=true;if(e.code==='KeyD')keys.d=true;if(e.code==='KeyR')resetBall();});
                window.addEventListener('keyup',e=>{if(e.code==='KeyA')keys.a=false;if(e.code==='KeyD')keys.d=false;});
                let isDrag=false,lx=0;
                const hs=x=>{if(physics.moving || !GameApp.myTurn){isDrag=true;lx=x;}}; 
                const hm=x=>{if(isDrag){orbitAngle+=(x-lx)*0.01;lx=x;}}; 
                const he=()=>{isDrag=false;};
                window.addEventListener('mousedown',e=>hs(e.clientX)); window.addEventListener('mousemove',e=>hm(e.clientX)); window.addEventListener('mouseup',he);
                window.addEventListener('touchstart',e=>{if(!e.target.closest('.control-btn'))hs(e.touches[0].clientX);},{passive:false});
                window.addEventListener('touchmove',e=>hm(e.touches[0].clientX),{passive:false}); window.addEventListener('touchend',he);
            }

            function updateEnvironment(type) {
                if(type==='LAVA') { scene.background = new THREE.Color(0x2a0a05); scene.fog = new THREE.Fog(0x2a0a05, 200, 3000); }
                else if(type==='ICE') { scene.background = new THREE.Color(0x0f172a); scene.fog = new THREE.Fog(0x0f172a, 200, 3000); }
                else { scene.background = new THREE.Color(0x050505); scene.fog = new THREE.Fog(0x050505, 200, 3000); }
            }

            function shakeCamera() { shakeIntensity = 1.0; }

            function initStage(d) {
                if(!scene) init();
                stageData=d; shots=0; physics.vel.set(0,0,0); physics.moving=false; gaugeState=0;
                updateEnvironment(d.type);
                
                document.getElementById('hud-planet-name').innerText=d.name;
                document.getElementById('hud-planet-info').innerText=`${d.gravity.toFixed(2)}g`;
                document.getElementById('hud-shots').innerText=0;
                document.getElementById('gauge-container-group').style.display='flex';
                document.getElementById('gauge-container-group').classList.remove('hidden');
                document.getElementById('minimap-container').style.display='block';
                document.getElementById('minimap-container').classList.remove('hidden');

                if(terrainMesh){scene.remove(terrainMesh);terrainMesh.geometry.dispose();}
                if(ball)scene.remove(ball);
                if(ghostBall){scene.remove(ghostBall);ghostBall=null;}
                if(trailMesh){scene.remove(trailMesh);trailMesh=null;} trailPts=[];
                if(gridHelper){scene.remove(gridHelper);gridHelper=null;}
                obstacles.forEach(o=>scene.remove(o)); obstacles=[];

                // Terrain
                const geo=new THREE.PlaneGeometry(4000,4000,150,150); geo.rotateX(-Math.PI/2);
                const pos=geo.attributes.position; const cols=[];
                const curve=new THREE.CatmullRomCurve3(d.pathPoints);
                pathLut=curve.getSpacedPoints(150);
                for(let i=0;i<pos.count;i++){
                    const x=pos.getX(i),z=pos.getZ(i);
                    let md=Infinity; for(let k=0;k<pathLut.length;k+=3){const dst=(x-pathLut[k].x)**2+(z-pathLut[k].z)**2; if(dst<md)md=dst;}
                    md=Math.sqrt(md);
                    
                    let y=0,c=new THREE.Color();
                    const dh=Math.sqrt((x-d.holePos.x)**2+(z-d.holePos.z)**2);
                    const noise = Math.sin(x*0.05)*Math.cos(z*0.05)*2; 

                    if(dh<30){y=0;c.setHex(0x22c55e);} 
                    else if(md<d.width){y=noise; c.setHex(d.color);} 
                    else if(md<d.width*2){y=15+noise*5; c.setHex(0x57534e);} 
                    else {y=40+(md-d.width*2)*0.8; c.setHex(0x292524);} 
                    pos.setY(i,y); cols.push(c.r,c.g,c.b);
                }
                geo.setAttribute('color',new THREE.Float32BufferAttribute(cols,3)); geo.computeVertexNormals();
                terrainMesh=new THREE.Mesh(geo,new THREE.MeshStandardMaterial({vertexColors:true,roughness:0.9}));
                terrainMesh.receiveShadow=true; scene.add(terrainMesh);

                // Ball
                ball=new THREE.Mesh(new THREE.SphereGeometry(2,16,16), new THREE.MeshStandardMaterial({color:0xffffff}));
                ball.castShadow=true; scene.add(ball);
                resetBall();

                // Ghost Ball (Red)
                if(GameApp.mode === 'MULTI') {
                    ghostBall = new THREE.Mesh(new THREE.SphereGeometry(2,16,16), new THREE.MeshBasicMaterial({color:0xff0000, wireframe:true}));
                    ghostBall.position.copy(ball.position);
                    scene.add(ghostBall);
                }

                // Goal
                const pole=new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,30),new THREE.MeshLambertMaterial({color:0xffffff}));
                pole.position.set(d.holePos.x,getTerrainHeight(d.holePos.x,d.holePos.z)+15,d.holePos.z);
                const fl=new THREE.Mesh(new THREE.BoxGeometry(10,6,0.5),new THREE.MeshLambertMaterial({color:0xff0000}));
                fl.position.set(5,12,0); pole.add(fl); scene.add(pole);

                const dir=new THREE.Vector3().subVectors(d.holePos,d.startPos).normalize();
                aimAngle=Math.atan2(-dir.x,-dir.z); orbitAngle=aimAngle;
                setTimeout(drawMinimap,500);
            }
            
            function updateGhostBall(pos) {
                if(ghostBall) ghostBall.position.set(pos.x, pos.y, pos.z);
            }

            const rc=new THREE.Raycaster(), dn=new THREE.Vector3(0,-1,0);
            function getTerrainHeight(x,z){if(!terrainMesh)return 0;rc.set(new THREE.Vector3(x,1000,z),dn);const h=rc.intersectObject(terrainMesh);return h.length>0?h[0].point.y:0;}
            function getTerrainNormal(x,z){if(!terrainMesh)return new THREE.Vector3(0,1,0);rc.set(new THREE.Vector3(x,1000,z),dn);const h=rc.intersectObject(terrainMesh);return h.length>0?h[0].face.normal:new THREE.Vector3(0,1,0);}

            function animate() {
                requestAnimationFrame(animate);
                if(!stageData) return;
                
                if(shakeIntensity > 0) { shakeIntensity -= 0.05; if(shakeIntensity<0) shakeIntensity=0; }
                
                // Controls Lock if not my turn
                if(!GameApp.myTurn) {
                    // Update camera to follow ghost ball or just stay
                    // Spectator Mode
                } else {
                    if(!physics.moving){ if(keys.a)aimAngle+=0.04; if(keys.d)aimAngle-=0.04; }
                    
                    if(gaugeState>0) {
                        gaugeAnim.pos+=2.5*gaugeAnim.dir;
                        if(gaugeAnim.pos>=100||gaugeAnim.pos<=0)gaugeAnim.dir*=-1;
                        const c=document.getElementById('gauge-cursor');
                        if(c){
                            c.style.left=gaugeAnim.pos+'%';
                            if(gaugeState===1)document.getElementById('gauge-power-fill').style.width=gaugeAnim.pos+'%';
                        }
                        if(gaugeState!==2 && !isPutting) {
                            document.getElementById('gauge-height-cursor').style.bottom=gaugeAnim.pos+'%';
                            document.getElementById('gauge-height-fill').style.height=gaugeAnim.pos+'%';
                        }
                    }
                }

                if(physics.moving) {
                    const dt=0.016, steps=4, sDt=dt/steps;
                    let sync=0;
                    for(let s=0; s<steps; s++) {
                        physics.vel.y -= (9.8*stageData.gravity)*sDt;
                        let np = ball.position.clone().add(physics.vel.clone().multiplyScalar(sDt*20.0));
                        
                        // Walls
                        let cp=pathLut[0], md=Infinity;
                        for(let k=0;k<pathLut.length;k+=5){const d=(np.x-pathLut[k].x)**2+(np.z-pathLut[k].z)**2;if(d<md){md=d;cp=pathLut[k];}}
                        if(Math.sqrt(md)>stageData.width*2.5){
                            physics.vel.x*=-0.5; physics.vel.z*=-0.5;
                            np.add(new THREE.Vector3().subVectors(cp,np).normalize().multiplyScalar(10));
                            SoundMgr.bounce(50); shakeCamera();
                        }

                        const gy=getTerrainHeight(np.x,np.z);
                        if(np.y<=gy+2){
                            np.y=gy+2; const n=getTerrainNormal(np.x,np.z);
                            if(physics.vel.y<0){
                                const d=physics.vel.dot(n);
                                physics.vel.add(n.clone().multiplyScalar(-2*d).multiplyScalar(0.6));
                                if(physics.vel.length()>5){ SoundMgr.bounce(physics.vel.length()); }
                            }
                            const friction = isPutting ? 0.96 : 0.985;
                            physics.vel.x*=friction; physics.vel.z*=friction;
                            
                            if(physics.vel.length()<2 && Math.abs(ball.position.y-(gy+2))<1){
                                physics.vel.set(0,0,0); physics.moving=false; 
                                if(GameApp.mode === 'MULTI') GameApp.sendTurnEnd(shots);
                                checkWin(); 
                                break;
                            }
                        }
                        
                        // Hole
                        const dh=np.distanceTo(new THREE.Vector3(stageData.holePos.x,np.y,stageData.holePos.z));
                        if(dh<3.0){
                            physics.vel.add(new THREE.Vector3().subVectors(new THREE.Vector3(stageData.holePos.x,np.y,stageData.holePos.z),np).normalize().multiplyScalar(2*sDt));
                            if(dh<1.0 && physics.vel.length()<30){ physics.vel.set(0,0,0); physics.moving=false; GameApp.finishStage(shots); break; }
                        }
                        ball.position.copy(np);
                        if(s===0) updateTrail(ball.position);
                        if(ball.position.y<-100){ resetBall(); break; }
                    }
                    sync++; if(sync>5){GameApp.sendPosUpdate(ball.position); sync=0;}
                }

                // Cam
                let ct;
                const targetBall = (GameApp.myTurn) ? ball : (ghostBall || ball);

                if(isPutting && GameApp.myTurn){
                    const th=new THREE.Vector3().subVectors(stageData.holePos,ball.position).normalize();
                    const cp=ball.position.clone().sub(th.multiplyScalar(20)); cp.y+=10;
                    camera.position.lerp(cp,0.1); camera.lookAt(stageData.holePos);
                } else {
                    const dist=60;
                    if(physics.moving) ct=new THREE.Vector3(targetBall.position.x-Math.sin(orbitAngle)*-dist,targetBall.position.y+30,targetBall.position.z-Math.cos(orbitAngle)*-dist);
                    else ct=new THREE.Vector3(targetBall.position.x-Math.sin(aimAngle)*-dist,targetBall.position.y+30,targetBall.position.z-Math.cos(aimAngle)*-dist);
                    if(shakeIntensity>0) { ct.x+=(Math.random()-0.5)*shakeIntensity; ct.y+=(Math.random()-0.5)*shakeIntensity; }
                    camera.position.lerp(ct,0.1); camera.lookAt(targetBall.position);
                }
                updateMinimap(); renderer.render(scene,camera);
            }

            function updateTrail(pos) {
                trailPts.push(pos.clone()); if(trailPts.length>50)trailPts.shift();
                if(trailMesh)scene.remove(trailMesh);
                trailMesh=new THREE.Line(new THREE.BufferGeometry().setFromPoints(trailPts), new THREE.LineBasicMaterial({color:0x4ade80,linewidth:2}));
                scene.add(trailMesh);
            }

            let glock=false;
            function triggerSpace(){
                if(physics.moving||glock || !GameApp.myTurn) return; 
                glock=true; setTimeout(()=>{glock=false;},200);
                const st=document.getElementById('gauge-status');
                if(isPutting){
                    if(gaugeState===0){gaugeState=1;gaugeAnim.pos=0;gaugeAnim.dir=1;st.innerText="PUTTING: POWER";}
                    else if(gaugeState===1){gaugeVals.p=gaugeAnim.pos;gaugeState=3;shoot();}
                } else {
                    if(gaugeState===0){gaugeState=1;gaugeAnim.pos=0;gaugeAnim.dir=1;st.innerText="TAP: POWER";}
                    else if(gaugeState===1){gaugeVals.p=gaugeAnim.pos;gaugeState=2;gaugeAnim.pos=0;gaugeAnim.dir=1;st.innerText="TAP: HEIGHT";}
                    else if(gaugeState===2){gaugeVals.h=gaugeAnim.pos;gaugeState=3;gaugeAnim.pos=50;gaugeAnim.dir=1;st.innerText="TAP: CURVE";}
                    else if(gaugeState===3){gaugeVals.c=(gaugeAnim.pos-50)/50;shoot();}
                }
            }

            function shoot(){
                gaugeState=0; shots++; SoundMgr.shot();
                document.getElementById('hud-shots').innerText=shots;
                document.getElementById('gauge-container-group').style.display='none';
                
                let p,ang,cur,fa;
                if(isPutting){
                    p=gaugeVals.p/100 * 40; ang=0; cur=0; fa=aimAngle;
                    physics.vel.set(-Math.sin(aimAngle)*p,0,-Math.cos(aimAngle)*p);
                } else {
                    p=gaugeVals.p/100 * 60; // Base 60
                    ang=(15+(gaugeVals.h/100)*60)*(Math.PI/180);
                    cur=gaugeVals.c*0.5; fa=aimAngle+cur;
                    physics.vel.set(-Math.sin(fa)*p*Math.cos(ang), p*Math.sin(ang), -Math.cos(fa)*p*Math.cos(ang));
                }
                physics.moving=true; orbitAngle=aimAngle; shakeCamera();
            }

            function resetBall(){
                if(!stageData)return; physics.vel.set(0,0,0); physics.moving=false;
                const y=getTerrainHeight(stageData.startPos.x,stageData.startPos.z);
                ball.position.set(stageData.startPos.x,y+2,stageData.startPos.z);
                updatePuttingState();
            }

            function checkWin(){ updatePuttingState(); }
            
            function updatePuttingState(){
                const d=ball.position.distanceTo(new THREE.Vector3(stageData.holePos.x,ball.position.y,stageData.holePos.z));
                const wp=isPutting; isPutting=(d<30);
                const g=document.getElementById('gauge-container-group'); const s=document.getElementById('gauge-status');
                g.style.display=(GameApp.myTurn)?'flex':'none'; // Hide UI if not my turn
                if(isPutting){
                    if(!wp){
                        if(!gridHelper){gridHelper=new THREE.GridHelper(60,20,0x00ff00,0x004400); gridHelper.position.set(stageData.holePos.x,getTerrainHeight(stageData.holePos.x,stageData.holePos.z)+0.2,stageData.holePos.z); scene.add(gridHelper);}
                    }
                    g.classList.add('putting-active'); s.innerText="PUTTING MODE";
                    const th=new THREE.Vector3().subVectors(stageData.holePos,ball.position).normalize(); aimAngle=Math.atan2(-th.x,-th.z);
                } else {
                    g.classList.remove('putting-active'); s.innerText="TAP SHOT";
                    if(gridHelper){scene.remove(gridHelper);gridHelper=null;}
                }
                document.getElementById('gauge-power-fill').style.width='0%';
                document.getElementById('gauge-height-fill').style.height='0%';
                gaugeState=0;
            }

            function drawMinimap() {
                if(!miniCtx||!stageData)return;
                miniCtx.fillStyle='#000'; miniCtx.fillRect(0,0,300,300);
                if(pathLut.length>0){
                    miniCtx.lineWidth=20; miniCtx.lineCap='round'; miniCtx.strokeStyle='#22c55e';
                    miniCtx.beginPath();
                    const s=300/4000, o=2000;
                    pathLut.forEach((p,i)=>{
                        const x=(p.x+o)*s, y=(p.z+o)*s;
                        if(i===0)miniCtx.moveTo(x,y); else miniCtx.lineTo(x,y);
                    });
                    miniCtx.stroke();
                }
                const s=300/4000, o=2000;
                const sx=(stageData.startPos.x+o)*s, sz=(stageData.startPos.z+o)*s;
                const hx=(stageData.holePos.x+o)*s, hz=(stageData.holePos.z+o)*s;
                miniCtx.fillStyle='#fff'; miniCtx.beginPath(); miniCtx.arc(sx,sz,4,0,Math.PI*2); miniCtx.fill();
                miniCtx.fillStyle='#ef4444'; miniCtx.beginPath(); miniCtx.arc(hx,hz,6,0,Math.PI*2); miniCtx.fill();
                minimapBg=miniCtx.getImageData(0,0,300,300);
            }
            function updateMinimap() {
                if(!minimapBg||!miniCtx)return; miniCtx.putImageData(minimapBg,0,0);
                const s=300/4000, o=2000;
                const bx=(ball.position.x+o)*s, bz=(ball.position.z+o)*s;
                miniCtx.fillStyle='#fff'; miniCtx.beginPath(); miniCtx.arc(bx,bz,3,0,Math.PI*2); miniCtx.fill();
                
                if(ghostBall){
                    const rx=(ghostBall.position.x+o)*s, rz=(ghostBall.position.z+o)*s;
                    miniCtx.fillStyle='#ff0000'; miniCtx.beginPath(); miniCtx.arc(rx,rz,3,0,Math.PI*2); miniCtx.fill();
                }
            }

            function setKey(k,v) { keys[k]=v; }
            return {init,initStage,resetBall,setKey,triggerSpace,updateGhostBall};
        })();

        window.onload=()=>GameApp.init();
    </script>
</body>
</html>
