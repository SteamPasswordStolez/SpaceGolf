<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Î¶¨Ïñº Ïö∞Ï£º Ï§ëÎ†• Í≥®ÌîÑ v0.1.4 (P2P Multi)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- PeerJS for P2P -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Noto+Sans+KR:wght@300;500;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Noto Sans KR', sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        .font-sci { font-family: 'Orbitron', sans-serif; }
        .hidden { display: none !important; }
        .fade-in { animation: fadeIn 0.5s ease-out forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        
        .btn-menu {
            background: linear-gradient(135deg, rgba(30, 58, 138, 0.6) 0%, rgba(88, 28, 135, 0.6) 100%);
            border: 1px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(12px);
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        .btn-menu:active { transform: scale(0.96); background: rgba(59, 130, 246, 0.8); }

        /* UI ÏöîÏÜåÎì§ (Í≤åÏù¥ÏßÄ, ÎØ∏ÎãàÎßµ Îì±) */
        #gauge-container-group { position: absolute; bottom: 120px; left: 50%; transform: translateX(-50%); display: none; gap: 15px; z-index: 50; align-items: flex-end; width: 90%; max-width: 500px; justify-content: center; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 20px; border: 1px solid #555; }
        #gauge-height-wrapper { width: 36px; height: 140px; background: #111; border: 2px solid #888; border-radius: 8px; position: relative; overflow: hidden; flex-shrink: 0; }
        #gauge-height-fill { width: 100%; height: 0%; bottom: 0; position: absolute; background: linear-gradient(to top, #2563eb, #a855f7); transition: height 0.05s linear; }
        #gauge-height-cursor { position: absolute; bottom: 0%; left: 0; width: 100%; height: 4px; background: #fff; z-index: 20; }
        #gauge-bar { width: 100%; height: 36px; background: #111; border: 2px solid #888; border-radius: 18px; position: relative; overflow: hidden; }
        #gauge-power-fill { height: 100%; width: 0%; position: absolute; top: 0; left: 0; background: linear-gradient(to right, #4ade80, #facc15, #ef4444); }
        #gauge-center-line { position: absolute; top: 0; left: 50%; width: 2px; height: 100%; background: rgba(255,255,255,0.8); z-index: 6; }
        .cursor-indicator { position: absolute; top: 0; height: 100%; width: 6px; background: #fff; z-index: 30; transform: translateX(-50%); }
        #minimap-container { position: absolute; top: 80px; right: 20px; width: 150px; height: 150px; background: #000; border: 3px solid #444; border-radius: 50%; overflow: hidden; z-index: 50; display: none; }
        #minimap-canvas { width: 100%; height: 100%; display: block; }
        .mobile-controls { display: none; position: absolute; bottom: 30px; z-index: 110; width: 100%; justify-content: space-between; padding: 0 30px; pointer-events: none; }
        .control-btn { pointer-events: auto; width: 80px; height: 80px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 28px; color: white; backdrop-filter: blur(8px); transition: 0.1s; }
        .control-btn:active { background: rgba(255,255,255,0.3); transform: scale(0.95); }
        .control-btn.shot-btn { width: 100px; height: 100px; background: linear-gradient(135deg, rgba(234, 179, 8, 0.3), rgba(234, 179, 8, 0.5)); border-color: #facc15; font-weight: 900; font-size: 20px; color: #fef08a; }
        
        #loader { position: fixed; inset: 0; background: #020617; z-index: 200; display: flex; justify-content: center; align-items: center; color: white; flex-direction: column; }
        .spinner { width: 50px; height: 50px; border: 5px solid #1e293b; border-top: 5px solid #3b82f6; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* P2P UI */
        #p2p-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 150; display: none; justify-content: center; align-items: center; flex-direction: column; }
        #room-code-display { font-size: 40px; font-weight: 900; color: #4ade80; letter-spacing: 5px; margin: 20px 0; font-family: 'Orbitron'; cursor: pointer; }
        #copy-msg { font-size: 12px; color: #888; margin-bottom: 20px; }
        .p2p-box { background: #1e293b; padding: 30px; border-radius: 20px; border: 1px solid #475569; text-align: center; width: 90%; max-width: 400px; }
        #multi-status { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); font-size: 12px; color: #4ade80; z-index: 60; display: none; background: rgba(0,0,0,0.7); padding: 5px 15px; border-radius: 20px; border: 1px solid #4ade80; }
    </style>
</head>
<body class="text-white">

    <div id="loader">
        <div class="spinner"></div>
        <p class="font-sci tracking-widest text-blue-400">INITIALIZING P2P MODULE...</p>
    </div>

    <div id="multi-status">üü¢ CONNECTED: 2 Players</div>

    <!-- Î°úÎπÑ -->
    <div id="lobby-screen" class="absolute inset-0 z-50 flex flex-col items-center justify-center bg-black/90 backdrop-blur-md fade-in hidden">
        <div class="text-center mb-8 mt-10 relative">
            <h1 class="text-5xl md:text-7xl font-black text-transparent bg-clip-text bg-gradient-to-br from-white to-slate-400 font-sci mb-2">
                GRAVITY<span class="text-blue-500">GOLF</span>
            </h1>
            <p class="text-slate-400 text-sm font-sci tracking-[0.5em]">P2P MULTIPLAYER v0.1.4</p>
        </div>
        
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 w-full max-w-4xl px-6 pb-10 overflow-y-auto" style="max-height: 65vh;">
            <button onclick="GameApp.selectMode('SPEED')" class="btn-menu p-6 rounded-2xl flex items-center gap-5 group">
                <div class="text-4xl">‚ö°</div>
                <div class="text-left"><h3 class="text-xl font-bold font-sci text-yellow-400">SPEED RUSH</h3><p class="text-xs text-slate-300">Single Player</p></div>
            </button>
            <button onclick="GameApp.selectMode('CASUAL')" class="btn-menu p-6 rounded-2xl flex items-center gap-5 group">
                <div class="text-4xl">üéí</div>
                <div class="text-left"><h3 class="text-xl font-bold font-sci text-green-400">CASUAL</h3><p class="text-xs text-slate-300">Free Roam</p></div>
            </button>
            <button onclick="GameApp.openP2P('HOST')" class="btn-menu p-6 rounded-2xl flex items-center gap-5 group bg-blue-900/20 border-blue-500/50">
                <div class="text-4xl">üè†</div>
                <div class="text-left"><h3 class="text-xl font-bold font-sci text-blue-400">CREATE ROOM</h3><p class="text-xs text-slate-300">Host Game</p></div>
            </button>
            <button onclick="GameApp.openP2P('JOIN')" class="btn-menu p-6 rounded-2xl flex items-center gap-5 group bg-purple-900/20 border-purple-500/50">
                <div class="text-4xl">üöÄ</div>
                <div class="text-left"><h3 class="text-xl font-bold font-sci text-purple-400">JOIN ROOM</h3><p class="text-xs text-slate-300">Enter Code</p></div>
            </button>
        </div>
    </div>

    <!-- P2P Î™®Îã¨ -->
    <div id="p2p-modal">
        <!-- Ìò∏Ïä§Ìä∏ ÌôîÎ©¥ -->
        <div id="p2p-host" class="p2p-box hidden">
            <h2 class="text-2xl font-bold font-sci mb-2">WAITING FOR PLAYER</h2>
            <p class="text-slate-400 text-sm">Share this code with your friend:</p>
            <div id="room-code-display" onclick="GameApp.copyCode()">-----</div>
            <p id="copy-msg">Click code to copy</p>
            <div class="animate-pulse text-yellow-400 text-sm mt-4">Waiting for connection...</div>
            <button onclick="GameApp.closeP2P()" class="mt-6 px-6 py-2 bg-slate-700 rounded-lg hover:bg-slate-600">CANCEL</button>
        </div>

        <!-- Ï°∞Ïù∏ ÌôîÎ©¥ -->
        <div id="p2p-join" class="p2p-box hidden">
            <h2 class="text-2xl font-bold font-sci mb-4">JOIN GAME</h2>
            <input type="text" id="room-code-input" placeholder="ENTER ROOM CODE" class="w-full bg-black/50 border border-slate-500 p-4 text-center text-2xl font-sci text-white rounded-lg mb-4 focus:border-blue-500 outline-none uppercase" maxlength="5">
            <button onclick="GameApp.connectToPeer()" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 rounded-lg mb-2">CONNECT üöÄ</button>
            <button onclick="GameApp.closeP2P()" class="w-full bg-slate-700 hover:bg-slate-600 text-white font-bold py-3 rounded-lg">CANCEL</button>
        </div>
    </div>

    <!-- Ïù∏Í≤åÏûÑ UI -->
    <div id="in-game-ui" class="absolute inset-0 pointer-events-none hidden z-10">
        <div class="absolute top-6 left-6 pointer-events-auto flex items-center gap-4 bg-black/60 p-3 rounded-2xl border border-white/10 backdrop-blur-md z-50 shadow-lg">
            <div class="w-10 h-10 rounded-full bg-gradient-to-br from-purple-600 to-blue-600 flex items-center justify-center text-xl shadow-inner">ü™ê</div>
            <div>
                <h2 id="hud-planet-name" class="text-base font-bold font-sci text-white leading-none mb-1">PLANET</h2>
                <p id="hud-planet-info" class="text-[10px] text-slate-300 font-mono tracking-wide">G: 1.00</p>
            </div>
        </div>
        <button onclick="ThreeScene.resetBall()" class="absolute top-6 left-1/2 transform -translate-x-1/2 pointer-events-auto bg-white/10 hover:bg-white/20 p-2 px-5 rounded-full text-[10px] font-bold border border-white/20 backdrop-blur-md transition z-50">‚Ü∫ RESPAWN</button>
        <div class="absolute top-6 right-6 text-right bg-black/60 p-3 rounded-2xl border border-white/10 backdrop-blur-md z-50">
            <div class="text-3xl font-black font-sci text-white leading-none"><span id="hud-shots">0</span></div>
            <div class="text-[10px] text-slate-400 font-bold tracking-widest">STROKES</div>
        </div>

        <!-- Í≤åÏù¥ÏßÄ -->
        <div id="gauge-container-group" class="pointer-events-auto">
            <div id="gauge-height-wrapper">
                <div class="absolute top-2 w-full text-center text-[8px] font-bold text-white/50 z-20">ANG</div>
                <div id="gauge-height-fill"></div>
                <div id="gauge-height-cursor"></div>
            </div>
            <div style="position: relative; flex-grow: 1;">
                <div id="gauge-status" class="absolute top-[-35px] left-0 font-bold text-yellow-400 text-xs font-sci tracking-wider bg-black/80 px-3 py-1 rounded-full border border-yellow-500/30">READY</div>
                <div id="gauge-bar">
                    <div id="gauge-center-line"></div>
                    <div id="gauge-power-fill"></div>
                    <div id="gauge-cursor" class="cursor-indicator" style="left:0%;"></div>
                </div>
            </div>
        </div>

        <div id="minimap-container"><canvas id="minimap-canvas"></canvas></div>

        <div class="mobile-controls flex" id="mobile-controls">
            <div class="flex gap-4 items-end pb-4">
                <button class="control-btn" id="btn-left">‚óÄ</button>
                <button class="control-btn" id="btn-right">‚ñ∂</button>
            </div>
            <div class="flex items-end pb-4">
                <button class="control-btn shot-btn" id="btn-shot">HIT</button>
            </div>
        </div>
    </div>

    <!-- Í≤∞Í≥º -->
    <div id="result-screen" class="hidden absolute inset-0 z-50 flex flex-col items-center justify-center bg-black/90 backdrop-blur-md fade-in">
        <h1 class="text-6xl font-black text-yellow-400 font-sci mb-6">CLEAR!</h1>
        <div class="bg-slate-800 p-8 rounded-2xl text-center">
            <div class="text-4xl font-bold mb-4" id="res-score">0</div>
            <button onclick="GameApp.returnToLobby()" class="bg-blue-600 px-8 py-3 rounded-xl font-bold hover:bg-blue-500">LOBBY</button>
        </div>
    </div>

    <div id="canvas-container" class="absolute inset-0 z-0"></div>

    <script>
        // ==========================================
        // 1. Planet DB
        // ==========================================
        const PlanetDB = (() => {
            const planets = [];
            for(let i=0; i<300; i++) {
                const mapSize = 4000;
                const pathPoints = [new THREE.Vector3(0,0,mapSize/2-200)];
                const segments = 4;
                for(let j=1; j<segments; j++) pathPoints.push(new THREE.Vector3((Math.random()-0.5)*2000, 0, (mapSize/2-200) - ((mapSize-400)*(j/segments))));
                pathPoints.push(new THREE.Vector3(0,0,-(mapSize/2-200)));
                planets.push({
                    id: i, name: `Planet-${i+1}`, gravity: 0.3 + (Math.random()*1.2), par: 3, color: 0x4ade80,
                    pathPoints, startPos: pathPoints[0], holePos: pathPoints[pathPoints.length-1], width: 150 
                });
            }
            return {
                get: (id) => planets[id%300],
                getRandom: () => planets[Math.floor(Math.random()*planets.length)]
            };
        })();

        // ==========================================
        // 2. Game App & P2P Logic
        // ==========================================
        const GameApp = {
            state: 'LOBBY', mode: null, currentStage: null, 
            peer: null, conn: null, myId: null, isHost: false,

            init() {
                ThreeScene.init();
                this.updateUI();
                this.setupTouchControls();
                document.getElementById('loader').classList.add('hidden');
            },

            setupTouchControls() {
                const press = (k,p) => ThreeScene.setKey(k,p);
                const prevent = e => { if(e.cancelable) e.preventDefault(); };
                
                ['left','right'].forEach(dir => {
                    const btn = document.getElementById(`btn-${dir}`);
                    btn.addEventListener('touchstart', e=>{ prevent(e); press(dir==='left'?'a':'d', true); });
                    btn.addEventListener('touchend', e=>{ prevent(e); press(dir==='left'?'a':'d', false); });
                    btn.addEventListener('mousedown', ()=>press(dir==='left'?'a':'d', true));
                    btn.addEventListener('mouseup', ()=>press(dir==='left'?'a':'d', false));
                });
                
                const shot = document.getElementById('btn-shot');
                shot.addEventListener('touchstart', e=>{ prevent(e); ThreeScene.triggerSpace(); shot.style.transform='scale(0.9)'; });
                shot.addEventListener('touchend', e=>{ prevent(e); shot.style.transform='scale(1)'; });
                shot.addEventListener('mousedown', ()=>{ ThreeScene.triggerSpace(); shot.style.transform='scale(0.9)'; });
                shot.addEventListener('mouseup', ()=>{ shot.style.transform='scale(1)'; });
            },

            updateUI() {
                ['lobby-screen','in-game-ui','result-screen','p2p-modal'].forEach(id => document.getElementById(id).classList.add('hidden'));
                if (this.state === 'LOBBY') document.getElementById('lobby-screen').classList.remove('hidden');
                else if (this.state === 'IN_GAME') {
                    document.getElementById('in-game-ui').classList.remove('hidden');
                    document.querySelector('.mobile-controls').style.display = 'flex';
                }
                else if (this.state === 'RESULT') document.getElementById('result-screen').classList.remove('hidden');
            },

            selectMode(mode) {
                this.mode = mode;
                this.startGame(PlanetDB.getRandom());
            },

            // --- P2P Methods ---
            openP2P(type) {
                document.getElementById('p2p-modal').style.display = 'flex';
                document.getElementById('p2p-host').classList.add('hidden');
                document.getElementById('p2p-join').classList.add('hidden');
                
                if(!this.peer) {
                    this.peer = new Peer(null, { debug: 2 }); // Random ID
                    this.peer.on('open', (id) => {
                        this.myId = id;
                        if(type === 'HOST') this.setupHost();
                    });
                    this.peer.on('connection', (c) => {
                        this.conn = c;
                        this.setupConnection();
                    });
                } else {
                    if(type === 'HOST') this.setupHost();
                }
                
                if(type === 'JOIN') document.getElementById('p2p-join').classList.remove('hidden');
            },

            setupHost() {
                this.isHost = true;
                document.getElementById('p2p-host').classList.remove('hidden');
                // Use last 5 chars as code for simplicity (Collision possible but low for demo)
                const code = this.myId.substr(-5).toUpperCase();
                document.getElementById('room-code-display').innerText = code;
            },

            connectToPeer() {
                const code = document.getElementById('room-code-input').value.trim();
                if(code.length < 5) return alert("Invalid Code");
                
                // Hack: We need full ID. In real app, use matchmaking server or full ID.
                // Here we assume players are exchanging full IDs or we use a deterministic ID prefix.
                // For this prototype, we ask user to input FULL ID if 5 chars fails? 
                // Let's rely on manual ID entry for robustness or basic peerjs functionality.
                // Wait, PeerJS IDs are long. Let's just alert the Full ID to the user for now.
                // Better: The host sees the full ID.
                // Update: Let's just use the Input value as the Peer ID.
                
                // User enters the FULL ID they saw on host screen (We will show full ID)
                this.isHost = false;
                this.conn = this.peer.connect(code); // Connect to peer
                this.setupConnection();
            },
            
            // Override setupHost to show full ID because partial ID lookup needs a server
            setupHost() {
                this.isHost = true;
                document.getElementById('p2p-host').classList.remove('hidden');
                document.getElementById('room-code-display').innerText = this.myId; // Show Full ID
                document.getElementById('room-code-display').style.fontSize = "16px";
            },

            setupConnection() {
                this.conn.on('open', () => {
                    document.getElementById('p2p-modal').style.display = 'none';
                    document.getElementById('multi-status').style.display = 'block';
                    
                    if(this.isHost) {
                        // Host selects map and sends to guest
                        const pid = Math.floor(Math.random()*300);
                        this.conn.send({ type: 'START', planetId: pid });
                        this.startGame(PlanetDB.get(pid));
                    }
                });

                this.conn.on('data', (data) => {
                    if(data.type === 'START') {
                        this.startGame(PlanetDB.get(data.planetId));
                    }
                    if(data.type === 'POS') {
                        ThreeScene.updateRemoteBall(data.pos);
                    }
                });
            },

            closeP2P() {
                document.getElementById('p2p-modal').style.display = 'none';
                if(this.conn) this.conn.close();
            },
            
            copyCode() {
                navigator.clipboard.writeText(this.myId);
                document.getElementById('copy-msg').innerText = "COPIED!";
                setTimeout(()=>document.getElementById('copy-msg').innerText="Click to copy", 1000);
            },

            sendMyPos(pos) {
                if(this.conn && this.conn.open) {
                    this.conn.send({ type: 'POS', pos: pos });
                }
            },

            startGame(stageData) {
                this.state = 'IN_GAME';
                this.currentStage = stageData;
                this.updateUI();
                ThreeScene.initStage(this.currentStage);
            },

            finishStage(shots) {
                this.state = 'RESULT';
                this.updateUI();
                document.getElementById('res-score').innerText = shots;
            },

            returnToLobby() { this.state = 'LOBBY'; this.updateUI(); },
        };

        // ==========================================
        // 3. Three.js Scene
        // ==========================================
        const ThreeScene = (() => {
            let scene, camera, renderer, ball, terrainMesh;
            let gaugeState=0, gaugeVals={p:0,h:0,c:0}, gaugeAnim={pos:0,dir:1};
            let physics={vel:new THREE.Vector3(), moving:false};
            let stageData, aimAngle=0, orbitAngle=0, shots=0;
            let miniCtx, minimapBg, keys={a:false, d:false};
            let remoteBall; 

            function init() {
                const container = document.getElementById('canvas-container');
                if(!container) return;
                scene = new THREE.Scene(); scene.background = new THREE.Color(0x050505); scene.fog = new THREE.Fog(0x050505, 200, 3000);
                camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 8000);
                renderer = new THREE.WebGLRenderer({antialias:true});
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                container.appendChild(renderer.domElement);
                const amb = new THREE.AmbientLight(0xffffff, 0.6); scene.add(amb);
                const sun = new THREE.DirectionalLight(0xffffff, 1.2); 
                sun.position.set(500,1000,500); sun.castShadow=true;
                sun.shadow.mapSize.set(2048,2048);
                sun.shadow.camera.far=5000; sun.shadow.camera.left=-2000; sun.shadow.camera.right=2000; sun.shadow.camera.top=2000; sun.shadow.camera.bottom=-2000;
                scene.add(sun);
                
                // Stars
                const sg = new THREE.BufferGeometry(); const sp = [];
                for(let i=0; i<3000; i++) sp.push((Math.random()-0.5)*8000, (Math.random()-0.5)*4000+2000, (Math.random()-0.5)*8000);
                sg.setAttribute('position', new THREE.Float32BufferAttribute(sp,3));
                scene.add(new THREE.Points(sg, new THREE.PointsMaterial({color:0xffffff, size:2})));

                const mc = document.getElementById('minimap-canvas'); 
                if(mc) { miniCtx = mc.getContext('2d'); mc.width=300; mc.height=300; }

                animate();
                
                window.addEventListener('resize', ()=>{ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
                window.addEventListener('keydown', (e) => {
                    if(e.code==='Space') triggerSpace();
                    if(e.code==='KeyA') keys.a = true; if(e.code==='KeyD') keys.d = true;
                    if(e.code==='KeyR') resetBall();
                });
                window.addEventListener('keyup', (e) => { if(e.code==='KeyA') keys.a = false; if(e.code==='KeyD') keys.d = false; });
                
                let isDrag=false, lastX=0;
                const hStart=x=>{if(physics.moving){isDrag=true; lastX=x;}};
                const hMove=x=>{if(isDrag){orbitAngle+=(x-lastX)*0.01; lastX=x;}};
                const hEnd=()=>{isDrag=false;};
                window.addEventListener('mousedown',e=>hStart(e.clientX)); window.addEventListener('mousemove',e=>hMove(e.clientX)); window.addEventListener('mouseup',hEnd);
                window.addEventListener('touchstart',e=>{if(!e.target.closest('.control-btn'))hStart(e.touches[0].clientX);},{passive:false});
                window.addEventListener('touchmove',e=>hMove(e.touches[0].clientX),{passive:false}); window.addEventListener('touchend',hEnd);
            }

            function updateRemoteBall(pos) {
                if(!remoteBall) {
                    remoteBall = new THREE.Mesh(new THREE.SphereGeometry(2,16,16), new THREE.MeshBasicMaterial({color:0x00ffff, wireframe:true}));
                    scene.add(remoteBall);
                }
                remoteBall.position.set(pos.x, pos.y, pos.z);
            }

            function initStage(data) {
                if(!scene) init();
                stageData = data; shots=0; physics.vel.set(0,0,0); physics.moving=false; gaugeState=0;
                
                document.getElementById('hud-planet-name').innerText = data.name;
                document.getElementById('hud-planet-info').innerText = `${data.gravity.toFixed(2)}g | Par ${data.par}`;
                document.getElementById('hud-shots').innerText = 0;
                document.getElementById('gauge-container-group').style.display = 'flex';
                document.getElementById('gauge-container-group').classList.remove('hidden');
                document.getElementById('minimap-container').style.display = 'block';
                document.getElementById('minimap-container').classList.remove('hidden');

                if(terrainMesh) { scene.remove(terrainMesh); terrainMesh.geometry.dispose(); }
                if(ball) scene.remove(ball);
                if(remoteBall) { scene.remove(remoteBall); remoteBall=null; }

                // Terrain
                const mapSize=4000, seg=150;
                const geo=new THREE.PlaneGeometry(mapSize,mapSize,seg,seg); geo.rotateX(-Math.PI/2);
                const pos=geo.attributes.position; const colors=[];
                const curve=new THREE.CatmullRomCurve3(data.pathPoints);
                const lut=curve.getSpacedPoints(150); 

                for(let i=0; i<pos.count; i++){
                    const x=pos.getX(i), z=pos.getZ(i);
                    let minD=Infinity;
                    for(let k=0; k<lut.length; k+=3) { 
                        const d = (x-lut[k].x)**2 + (z-lut[k].z)**2;
                        if(d<minD) minD=d;
                    }
                    minD = Math.sqrt(minD);
                    let y=0, c=new THREE.Color();
                    const dH = Math.sqrt((x-data.holePos.x)**2+(z-data.holePos.z)**2);
                    if(dH<30) { y=0; c.setHex(0x22c55e); }
                    else if(minD < data.width) { y=Math.sin(x*0.02)*2; c.setHex(data.color); }
                    else if(minD < data.width*2) { y=10; c.setHex(0x57534e); }
                    else { y=30+(minD-data.width*2)*0.5; c.setHex(0x292524); }
                    pos.setY(i,y); colors.push(c.r,c.g,c.b);
                }
                geo.setAttribute('color', new THREE.Float32BufferAttribute(colors,3)); geo.computeVertexNormals();
                terrainMesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({vertexColors:true, roughness:0.9}));
                terrainMesh.receiveShadow=true; scene.add(terrainMesh);

                ball = new THREE.Mesh(new THREE.SphereGeometry(2,16,16), new THREE.MeshStandardMaterial({color:0xffffff}));
                ball.castShadow=true; scene.add(ball);
                resetBall();

                const pole=new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,30), new THREE.MeshLambertMaterial({color:0xffffff}));
                pole.position.set(data.holePos.x, getTerrainHeight(data.holePos.x, data.holePos.z)+15, data.holePos.z);
                const flag=new THREE.Mesh(new THREE.BoxGeometry(10,6,0.5), new THREE.MeshLambertMaterial({color:0xff0000}));
                flag.position.set(5,12,0); pole.add(flag); scene.add(pole);

                const dir = new THREE.Vector3().subVectors(data.holePos, data.startPos).normalize();
                aimAngle = Math.atan2(-dir.x, -dir.z); orbitAngle=aimAngle;
                setTimeout(drawMinimap, 500);
            }

            const ray = new THREE.Raycaster(); const down = new THREE.Vector3(0,-1,0);
            function getTerrainHeight(x,z) {
                if(!terrainMesh) return 0;
                ray.set(new THREE.Vector3(x, 1000, z), down);
                const hits = ray.intersectObject(terrainMesh); return hits.length>0?hits[0].point.y:0;
            }
            function getTerrainNormal(x,z) {
                if(!terrainMesh) return new THREE.Vector3(0,1,0);
                ray.set(new THREE.Vector3(x, 1000, z), down);
                const hits = ray.intersectObject(terrainMesh); return hits.length>0?hits[0].face.normal:new THREE.Vector3(0,1,0);
            }

            function animate() {
                requestAnimationFrame(animate);
                if(!stageData) return;

                if(!physics.moving) {
                    if(keys.a) aimAngle += 0.04;
                    if(keys.d) aimAngle -= 0.04;
                }

                if(gaugeState > 0) {
                    gaugeAnim.pos += 2.5 * gaugeAnim.dir;
                    if(gaugeAnim.pos>=100||gaugeAnim.pos<=0) gaugeAnim.dir*=-1;
                    const cur = document.getElementById('gauge-cursor');
                    if(cur) {
                        if(gaugeState === 3) cur.classList.add('cursor-curve'); else cur.classList.remove('cursor-curve');
                        if(gaugeState!==2) {
                            cur.style.left=gaugeAnim.pos+'%';
                            if(gaugeState===1) document.getElementById('gauge-power-fill').style.width=gaugeAnim.pos+'%';
                        } else {
                            document.getElementById('gauge-height-cursor').style.bottom=gaugeAnim.pos+'%';
                            document.getElementById('gauge-height-fill').style.height=gaugeAnim.pos+'%';
                        }
                    }
                }

                if(physics.moving) {
                    const dt=0.016, steps=4, stepDt=dt/steps;
                    let sync=0;
                    for(let s=0; s<steps; s++) {
                        physics.vel.y -= (9.8*stageData.gravity)*stepDt;
                        let nextPos = ball.position.clone().add(physics.vel.clone().multiplyScalar(stepDt*20.0));
                        
                        const gy = getTerrainHeight(nextPos.x, nextPos.z);
                        if(nextPos.y <= gy+2) {
                            nextPos.y = gy+2;
                            const norm = getTerrainNormal(nextPos.x, nextPos.z);
                            if(physics.vel.y<0) {
                                const d = physics.vel.dot(norm);
                                physics.vel.add(norm.clone().multiplyScalar(-2*d).multiplyScalar(0.6));
                            }
                            physics.vel.x*=0.995; physics.vel.z*=0.995; 
                            if(physics.vel.length()<2 && Math.abs(ball.position.y-(gy+2))<1) {
                                physics.vel.set(0,0,0); physics.moving=false; checkWin(); break;
                            }
                        }
                        ball.position.copy(nextPos);
                        if(ball.position.y<-100) { resetBall(); break; }
                    }
                    sync++;
                    if(sync>5) { GameApp.sendMyPos(ball.position); sync=0; }
                }

                let ct, dist=60;
                if(physics.moving) ct=new THREE.Vector3(ball.position.x-Math.sin(orbitAngle)*-dist, ball.position.y+30, ball.position.z-Math.cos(orbitAngle)*-dist);
                else ct=new THREE.Vector3(ball.position.x-Math.sin(aimAngle)*-dist, ball.position.y+30, ball.position.z-Math.cos(aimAngle)*-dist);
                camera.position.lerp(ct, 0.1); camera.lookAt(ball.position);

                updateMinimap();
                renderer.render(scene, camera);
            }

            let gaugeLock = false;
            function triggerSpace() {
                if(physics.moving || gaugeLock) return;
                gaugeLock = true; setTimeout(() => { gaugeLock = false; }, 200);
                const stat = document.getElementById('gauge-status');
                if(gaugeState === 0) { gaugeState = 1; gaugeAnim.pos = 0; gaugeAnim.dir = 1; stat.innerText = "TAP: POWER"; }
                else if(gaugeState === 1) { gaugeVals.p = gaugeAnim.pos; gaugeState = 2; gaugeAnim.pos = 0; gaugeAnim.dir = 1; stat.innerText = "TAP: HEIGHT"; }
                else if(gaugeState === 2) { gaugeVals.h = gaugeAnim.pos; gaugeState = 3; gaugeAnim.pos = 50; gaugeAnim.dir = 1; stat.innerText = "TAP: CURVE"; }
                else if(gaugeState === 3) { gaugeVals.c = (gaugeAnim.pos - 50) / 50; shoot(); }
            }

            function shoot() {
                gaugeState=0; shots++;
                document.getElementById('hud-shots').innerText=shots;
                document.getElementById('gauge-container-group').style.display='none';
                let p = gaugeVals.p/100 * 85; 
                const ang = (15 + (gaugeVals.h/100)*60) * (Math.PI/180);
                const cur = gaugeVals.c*0.5;
                const fa = aimAngle+cur;
                const vxz = p*Math.cos(ang); const vy=p*Math.sin(ang);
                physics.vel.set(-Math.sin(fa)*vxz, vy, -Math.cos(fa)*vxz);
                physics.moving=true; orbitAngle=aimAngle;
            }

            function resetBall() {
                if(!stageData) return;
                physics.vel.set(0,0,0); physics.moving=false;
                const y=getTerrainHeight(stageData.startPos.x, stageData.startPos.z);
                ball.position.set(stageData.startPos.x, y+2, stageData.startPos.z);
                document.getElementById('gauge-container-group').style.display='flex';
                document.getElementById('gauge-status').innerText="TAP SHOT";
                document.getElementById('gauge-power-fill').style.width='0%';
                document.getElementById('gauge-height-fill').style.height='0%';
                gaugeState = 0; 
                GameApp.sendMyPos(ball.position);
            }

            function checkWin() {
                const d = ball.position.distanceTo(new THREE.Vector3(stageData.holePos.x, ball.position.y, stageData.holePos.z));
                if(d<15) GameApp.finishStage(shots);
                else {
                    document.getElementById('gauge-container-group').style.display='flex';
                    document.getElementById('gauge-status').innerText="TAP SHOT";
                    gaugeState = 0; 
                }
                GameApp.sendMyPos(ball.position);
            }

            function drawMinimap() {
                if(!miniCtx || !stageData) return;
                miniCtx.fillStyle='#000'; miniCtx.fillRect(0,0,300,300);
                // Draw path...
                const mapScale = 300 / 4000; const offset = 2000;
                const sx=(stageData.startPos.x+offset)*mapScale; const sz=(stageData.startPos.z+offset)*mapScale;
                const hx=(stageData.holePos.x+offset)*mapScale; const hz=(stageData.holePos.z+offset)*mapScale;
                miniCtx.fillStyle='#fff'; miniCtx.beginPath(); miniCtx.arc(sx,sz,4,0,Math.PI*2); miniCtx.fill();
                miniCtx.fillStyle='#ef4444'; miniCtx.beginPath(); miniCtx.arc(hx,hz,6,0,Math.PI*2); miniCtx.fill();
                minimapBg=miniCtx.getImageData(0,0,300,300);
            }
            function updateMinimap() {
                if(!minimapBg || !miniCtx) return;
                miniCtx.putImageData(minimapBg,0,0);
                const mapScale = 300 / 4000; const offset = 2000;
                const bx=(ball.position.x+offset)*mapScale; const bz=(ball.position.z+offset)*mapScale;
                miniCtx.fillStyle='#fff'; miniCtx.beginPath(); miniCtx.arc(bx,bz,3,0,Math.PI*2); miniCtx.fill();
                
                // Remote
                if(remoteBall) {
                    const rx=(remoteBall.position.x+offset)*mapScale; const rz=(remoteBall.position.z+offset)*mapScale;
                    miniCtx.fillStyle='#0ff'; miniCtx.beginPath(); miniCtx.arc(rx,rz,2,0,Math.PI*2); miniCtx.fill();
                }
            }

            function setKey(k,v) { keys[k]=v; }
            return { init, initStage, resetBall, setKey, triggerSpace, updateRemoteBall };
        })();

        window.onload = () => GameApp.init();
    </script>
</body>
</html>
